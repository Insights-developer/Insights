// Custom authentication login endpoint
import { NextRequest, NextResponse } from 'next/server';
import { createSessionCookie } from '@/utils/auth';
import { transaction } from '@/utils/db';

interface DebugStep {
  step: string;
  timestamp: string;
  [key: string]: any;
}

interface DebugData {
  startTime: string;
  steps: DebugStep[];
  userId?: string;
  [key: string]: any;
}

export async function POST(request: NextRequest) {
  // Create debug object to track login process
  const debugData: DebugData = {
    startTime: new Date().toISOString(),
    steps: []
  };
  
  try {
    const { email, password } = await request.json();
    debugData.steps.push({ step: 'request_parsed', timestamp: new Date().toISOString() });
    
    // Basic validation
    if (!email || !password) {
      debugData.steps.push({ 
        step: 'validation_failed', 
        reason: !email ? 'email_missing' : 'password_missing',
        timestamp: new Date().toISOString()
      });
      
      return NextResponse.json(
        { 
          error: 'Email and password are required',
          debug: process.env.NODE_ENV === 'development' ? debugData : undefined
        },
        { status: 400 }
      );
    }
    
    // Use transaction to safely handle database operations
    return await transaction(async (client) => {
      debugData.steps.push({ step: 'transaction_started', timestamp: new Date().toISOString() });
      
      // Check if verify_password function exists
      try {
        const functionCheckResult = await client.query(
          `SELECT EXISTS (
            SELECT 1 FROM pg_proc 
            WHERE proname = 'verify_password' 
            AND pg_function_is_visible(oid)
          ) AS function_exists`
        );
        
        const verifyPasswordExists = functionCheckResult.rows[0].function_exists;
        debugData.steps.push({ 
          step: 'check_verify_function', 
          exists: verifyPasswordExists,
          timestamp: new Date().toISOString()
        });
        
        if (!verifyPasswordExists) {
          return NextResponse.json(
            { 
              error: 'Authentication system is not fully set up. The verify_password function is missing.',
              debug: process.env.NODE_ENV === 'development' ? debugData : undefined
            },
            { status: 500 }
          );
        }
      } catch (functionCheckError) {
        debugData.steps.push({ 
          step: 'function_check_error',
          error: (functionCheckError as Error).message,
          timestamp: new Date().toISOString()
        });
        // Continue with the login attempt even if we can't check for the function
      }
      
      // Get user by email
      let user;
      try {
        const userResult = await client.query(
          'SELECT id, email, password_hash, account_locked FROM users WHERE email = $1',
          [email]
        );
        
        debugData.steps.push({ 
          step: 'user_query_executed', 
          found: userResult.rowCount > 0,
          timestamp: new Date().toISOString()
        });
        
        if (userResult.rowCount === 0) {
          debugData.steps.push({ 
            step: 'auth_failed',
            reason: 'user_not_found', 
            timestamp: new Date().toISOString()
          });
          
          return NextResponse.json(
            { 
              error: 'Invalid email or password',
              debug: process.env.NODE_ENV === 'development' ? debugData : undefined
            },
            { status: 401 }
          );
        }
        
        user = userResult.rows[0];
        debugData.userId = user.id;
        
        // Check if account is locked
        if (user.account_locked) {
          debugData.steps.push({ 
            step: 'auth_failed',
            reason: 'account_locked', 
            timestamp: new Date().toISOString()
          });
          
          return NextResponse.json(
            { 
              error: 'Account is locked. Please contact support.',
              debug: process.env.NODE_ENV === 'development' ? debugData : undefined
            },
            { status: 403 }
          );
        }
        
        // Check password hash format
        const hashValid = user.password_hash && 
                          typeof user.password_hash === 'string' && 
                          user.password_hash.startsWith('$2');
        
        debugData.steps.push({ 
          step: 'password_hash_check', 
          valid: hashValid,
          timestamp: new Date().toISOString()
        });
        
        if (!hashValid) {
          return NextResponse.json(
            { 
              error: 'Account setup incomplete. Please use password reset to set a new password.',
              debug: process.env.NODE_ENV === 'development' ? debugData : undefined
            },
            { status: 400 }
          );
        }
      } catch (userQueryError) {
        debugData.steps.push({ 
          step: 'user_query_error',
          error: (userQueryError as Error).message,
          timestamp: new Date().toISOString()
        });
        
        return NextResponse.json(
          { 
            error: 'Database error while retrieving user information',
            debug: process.env.NODE_ENV === 'development' ? debugData : undefined
          },
          { status: 500 }
        );
      }
      
      // Verify password using database function
      try {
        const passwordResult = await client.query(
          'SELECT verify_password($1, $2) AS valid',
          [password, user.password_hash]
        );
        
        let isValid = passwordResult.rows[0].valid;
        
        debugData.steps.push({ 
          step: 'db_password_verification',
          success: isValid, 
          timestamp: new Date().toISOString()
        });
        
        // If verification fails with DB function, try direct comparison with bcrypt in Node.js as fallback
        if (!isValid) {
          const bcrypt = require('bcrypt');
          try {
            const nodeVerification = await bcrypt.compare(password, user.password_hash);
            
            debugData.steps.push({ 
              step: 'node_password_verification',
              success: nodeVerification, 
              timestamp: new Date().toISOString()
            });
            
            if (nodeVerification) {
              // If Node.js verification succeeds but Postgres failed, use this result instead
              isValid = nodeVerification;
            }
          } catch (bcryptErr) {
            debugData.steps.push({ 
              step: 'node_bcrypt_error',
              error: (bcryptErr as Error).message, 
              timestamp: new Date().toISOString()
            });
          }
        }
        
        if (!isValid) {
          // Increment failed login attempts
          await client.query(
            'UPDATE users SET failed_login_attempts = failed_login_attempts + 1 WHERE id = $1',
            [user.id]
          );
          
          // Check if we should lock the account (5+ failed attempts)
          const attemptsResult = await client.query(
            'SELECT failed_login_attempts FROM users WHERE id = $1',
            [user.id]
          );
          
          debugData.steps.push({ 
            step: 'failed_attempts_updated',
            attempts: attemptsResult.rows[0].failed_login_attempts,
            timestamp: new Date().toISOString()
          });
          
          if (attemptsResult.rows[0].failed_login_attempts >= 5) {
            await client.query(
              'UPDATE users SET account_locked = true WHERE id = $1',
              [user.id]
            );
            
            debugData.steps.push({ 
              step: 'account_locked',
              timestamp: new Date().toISOString()
            });
          }
          
          return NextResponse.json(
            { 
              error: 'Invalid email or password',
              debug: process.env.NODE_ENV === 'development' ? debugData : undefined
            },
            { status: 401 }
          );
        }
        
        // Generate session token
        const tokenResult = await client.query('SELECT generate_secure_token() AS token');
        const sessionToken = tokenResult.rows[0].token;
        
        debugData.steps.push({ 
          step: 'token_generated',
          timestamp: new Date().toISOString()
        });
        
        // Set session expiration (16 hours)
        const expires = new Date();
        expires.setHours(expires.getHours() + 16);
        
        try {
          // Create session record
          await client.query(
            'INSERT INTO user_sessions(user_id, token, expires_at, ip_address, user_agent) VALUES($1, $2, $3, $4, $5)',
            [
              user.id, 
              sessionToken, 
              expires.toISOString(), 
              request.headers.get('x-forwarded-for') || 'unknown',
              request.headers.get('user-agent') || 'unknown'
            ]
          );
          
          debugData.steps.push({ 
            step: 'session_created',
            expiresAt: expires.toISOString(),
            timestamp: new Date().toISOString()
          });
        } catch (sessionError) {
          debugData.steps.push({ 
            step: 'session_creation_failed',
            error: (sessionError as Error).message,
            timestamp: new Date().toISOString()
          });
          
          // Continue anyway, we'll just return a cookie even if DB record failed
        }
        
        // Reset failed attempts and update login timestamps
        try {
          await client.query(
            'UPDATE users SET failed_login_attempts = 0, last_login = $1, current_login_at = $1 WHERE id = $2',
            [new Date().toISOString(), user.id]
          );
          
          debugData.steps.push({ 
            step: 'login_timestamps_updated',
            timestamp: new Date().toISOString()
          });
        } catch (updateError) {
          debugData.steps.push({ 
            step: 'timestamp_update_failed',
            error: (updateError as Error).message,
            timestamp: new Date().toISOString()
          });
          // Continue anyway as this is not critical
        }
        
        // Get user features
        let features: string[] = [];
        try {
          const featuresResult = await client.query(
            `SELECT f.key 
             FROM features f
             JOIN access_group_features agf ON f.key = agf.feature
             JOIN user_access_groups uag ON agf.group_id = uag.group_id
             WHERE uag.user_id = $1`,
            [user.id]
          );
          
          features = featuresResult.rows.map((row: { key: string }) => row.key);
          
          debugData.steps.push({ 
            step: 'features_loaded',
            count: features.length,
            timestamp: new Date().toISOString()
          });
        } catch (featuresError) {
          debugData.steps.push({ 
            step: 'features_load_failed',
            error: (featuresError as Error).message,
            timestamp: new Date().toISOString()
          });
          // Continue anyway with empty features
        }
        
        // Create JWT token and set cookie
        try {
          const cookieValue = await createSessionCookie(user.id, sessionToken, expires);
          
          debugData.steps.push({ 
            step: 'jwt_token_created',
            timestamp: new Date().toISOString()
          });
          
          // Create response with user data
          const response = NextResponse.json({
            user: { 
              id: user.id, 
              email: user.email 
            },
            features,
            sessionExpires: expires.toISOString(),
            debug: process.env.NODE_ENV === 'development' ? debugData : undefined
          });
          
          // Set the session cookie in the response
          response.cookies.set('session', cookieValue, {
            httpOnly: true,
            expires,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'lax',
            path: '/'
          });
          
          debugData.steps.push({ 
            step: 'login_complete',
            success: true,
            timestamp: new Date().toISOString()
          });
          
          // Return the response with cookie
          return response;
        } catch (tokenError) {
          debugData.steps.push({ 
            step: 'jwt_creation_failed',
            error: (tokenError as Error).message,
            timestamp: new Date().toISOString()
          });
          
          return NextResponse.json(
            { 
              error: 'Failed to create authentication token',
              debug: process.env.NODE_ENV === 'development' ? debugData : undefined
            },
            { status: 500 }
          );
        }
      } catch (verifyError) {
        debugData.steps.push({ 
          step: 'password_verification_error',
          error: (verifyError as Error).message,
          timestamp: new Date().toISOString()
        });
        
        return NextResponse.json(
          { 
            error: 'Password verification failed due to a system error. Please try again.',
            debug: process.env.NODE_ENV === 'development' ? debugData : undefined
          },
          { status: 500 }
        );
      }
    });
  } catch (err) {
    console.error('Login error:', err);
    
    const errorDebug = {
      ...debugData,
      steps: [
        ...(debugData.steps || []),
        { 
          step: 'critical_error',
          error: (err as Error).message,
          timestamp: new Date().toISOString()
        }
      ]
    };
    
    return NextResponse.json(
      { 
        error: 'Login failed. Please try again.',
        debug: process.env.NODE_ENV === 'development' ? errorDebug : undefined
      },
      { status: 500 }
    );
  }
}
